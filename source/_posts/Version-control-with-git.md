---
title: Version control with git
tags:
---

## Why do I need version control?
Think about the day when we used to have folder names for out projects like project-start, project-final, project-final2, project-last-final etc. We used to duplicate project every time to backup a previous version for safety. Version control solves this problem. It is a system which records and stores every changes made to a project, with the flexibility of allowing you to go back to a previous state at any time. Developers have been using this method for a long time (trust me it exists from the 70s) and it is now unthinkable to seriously write software without one.

<!-- more -->

## Installation
Git is the most popular version control tool used today, so we will be taking a look at how we can make use of this powerful tool to make our lives easier. Before installing git you might want to check whether git is already installed. You can open the terminal and type `git --version` to check the exact version that you have or you could do `which git` to find the location of git. If you don't have git installed, then you can head over to the downloads section of the [official git website](https://git-scm.com/downloads) and download the git installer based on your operating system to install it on your computer. The installation process is pretty simple and the installer will guide you through.

## Initial Configuration
Before we start using git for our projects, we need to configure git to suit our needs, just like how we would configure a text editor before we start writing code.Its important to note her that git allows us to provide configuration at 3 different levels.
- System - Configurations at this level apply to all the users of the system
- User - Configurations at this level apply to a specific users of the system
- Project - Configurations at this level apply to the project alone

The system level configurations are stored at `/etc/gitconfig`, the user level configurations are stored at `~/.gitconfig`, the project level configurations are stored at `project_root_folder/.git/config`. These are just plain text files, to change the configurations at any particular level we could very well just go and edit these file manually, but the issue here is that we have to also understand the format in which we must write the configuration in these file. Git simplifies this process by providing us some commands to edit these configurations.

Using the git command we edit the configuration like this. `git config --system <configuration>` for a system wide configuration, or `git config --global <configuration>` for a user level configuration, and `git config <configuration>` for a project level configuration.

Lets add a few user level configurations to get us started with git. The first thing is, you need to tell git about yourself i.e your name and email address. Because when you are working on a project with multiple team members and when you make a change with git, it marks that change with your identity so that others can know the person who was responsible behind writing that piece of code. You can also tell git the default text editor that you want it to use. Git uses that text editor to open files when it wants you to enter some message. Along with the text editor we also provide it with 2 options `w` meaning telling unix to wait till we complete entering the message(if we don't do this unix will not wait till we complete writing the message and it will keep going with what it needs to do) and `l1` means put the cursor at line number 1. Another configuration that we can add is to tell git to use colors when outputing things to the command line, if we don't add this configuration it will just give us monochromatic text. 
```sh
git config --global user.name "Raj Abishek"
git config --global user.email "rajabishek@hotmail.com"
git config --global core.editor "sublime -wl1"
git config --global color.ui true
git config --global --list #Show all the configurations
git config --global user.name #Show's the name
git config --global user.email #Show's the email address
```

## Getting help from git
You can use the `git help` command to get help from git. This will list all the commonly used commands that git provides along with a short note on each one of them. To know more about how to use a specific command we can do `git help <command>` to get details about using that git command, it actually brings out the git manual page for that command, the page has the description about that command and the options that we can use along with it. Use can use f key to move forward and b to move backward while reading the documentation in the git man page. When you are finally done you can hot q to quit out. Unix users will recognize that the manual page that was opened was a typical Unix man page.  In fact its was the very same thing, you could have also opened it using `man git-log`. Git help just gives you an easier way to look at those manual pages through its command line tool.

## Initializing a repository
Before we start using git for a project we need to initialize a repository, what I mean is that we need to tell git which is the folder that it needs to keep track of. The first step that we do is we navigation to the project's root folder and run the `git init` command there. This tell git to do the initialization process, i.e start doing what you need to do, to track this folder. What git internally does is that it create a .git folder in the project's root where it store all the git related information. Its important to note here that this .git folder is that only place where git stores all the information, unlike other version control systems like SVN it doesn't include a tracking file in every single directory down the line ( To remove SVN you will have to go through all pull out all the tracking file present in every directory). Since this is the only place where git stores all of the git related information for the project, if we needed to remove version control from the project, all that we need to do is remove this folder `sudo rm -rf .git`.

## Basic git workflow
1. Make the changes
1. Add the changes ( Adds the files to the staging area - more on this later )
1. Commit changes to the repository with a message

## Looking through the commit made
`git log` command allows us to see the commits that have been made so far. For example to see the recent 5 commits what we do `git log -n 5` to get the last 5 commits that have been made. `git log --since=2016-08-1` will should the commits that have been made after 1st of August 2016.(This is exclusive doesn't include commits made on 1st of August). Similarly the command `git log --until/before=2016-08-1` will show commits that have been made before 1st August 2016.( This is inclusive, includes the commits made on 1st of August). You can also pass something interesting in the dates. You can do something like `git log --since="2 weeks ago"` to get the commits from the last 2 weeks. You can even combine since and util options in the git log command. `git log --since="2 weeks ago" --until="3 days ago"` shows the commits that have happened since 3 weeks ago and it will show the results only till 3 days ago, the commits made during the last 3 days wont be shown. And another was you could write this command is `git log --since=2.weeks --until=3.days`.

You also look for commits that have been made by a specific author, you need not search by the full name, you can just provide git a part of the author's name and git will search for you. `git log --author="Raj"` will search for all commits that have been made by authors who's name has the word "Raj". We can also search the commits by the commit message, `git log --grep="hello"` will bring out all commits that have the word hello in the commit message. `grep` stands for gllbalk regular expression.

## The three-tree architecture
Git uses a three tree architecture, i.e we have 3 trees the working copy, staging area, and the repository. We call each one of them a tree because each one them represents a folder structure. In fact when we did an add we are actually adding file to the staging area. From there we commit to the repository. It is possible to go ahead and commit directly to the repository and skip the staging step, we will look into that in a moment. The whole point of having a staging area is to make and get things ready, lets say we have 10 files that have changed in our project( working copy), now if we don't want to commit all these changes at once as a single change set(a commit), then this is where the staging area comes in handy. We can just add those files that we want to a part of the first change set to the staging area and commit them alone. Next we can take the remaining changes from the working copy and do that same. The staging area acts like a workplace where we can arrange and group things that we want to be a part of one change set. Now we also have the option to pull changes from the repository to the staging index, and then from there to the working copy, buts that's not usually the way we work. Whenever we are pulling changes from the repository we pull it directly to the working copy.

## How git refers to the change sets ?
Git generates a checksum for each change set. Checksum algorithms convert data into a simple number called as the checksum. How many ever times you feed the same data the checksum algorithm always generates the same checksum. Changing the data would change the checksum. Git uses SHA-1 hash algorithm to generate the checksum. Its a 40 character hexadecimal string. We have seen this checksum before if you remember, when we do a git log we see this checksum that is generated for each commit there. Therefore every commit has this meta information the checksum, the author details and a reference to the checksum of the previous commit called as parent. In fact we can use these checksums to search for the commits also. 

## Demystifying the HEAD pointer
We also have something called as the HEAD pointer in git. HEAD always points to the tip of the current branch in the repository, it's the last state of the repository, what was last checkout out. Or you can visualize as HEAD pointing to the parent of the next commit, i.e where the writing will start taking place. Its the place where we left off, its the place from where we are going to make any further changes.

Lets take a look at how git keep track of HEAD. Inside the .git folder there is a file called HEAD and that what git uses to know where the head is pointing. If you see the contents of the file you find a path, if you follow that path, you would actually lead to the SHA value of the most recent commit made in the current branch. When we are doing `git log` its the same thing as `git log HEAD` starting from the HEAD go backwards and show me the log.

## Revisiting some basic git commands
One of the most important commands in git is the `git status` command, it reports us the difference between the three trees in git. Whenever you don't know what to do when you are working with git at any particular time, use this command, it will tell you what to do. The difference between the working, staging and the repository. Its also shows the current branch that we are on. Lets say that you add 2 new files, now when you run `git status` it says that you have 2 untracked files. All that it is trying to tell us is that it has the information about the repository and it has found that there are 2 new files in the working copy that are not there in the repository. Working copy has new things that got is not current tracking.

Now to add files to the staging index we do `git add <path-to-file>` or we can add all files in a folder `git add <path-to-folder>`. This will add all the changes in the path to the staging area from where we can make a commit. Now when we do `git status` the things under the changes to be committed section are the file that are there in the staging area.

Now to commit the changes in the staging are we do `git commit -m "This is the commit message"` the `-m` option is used to provide a message along with a commit. When you do a commit you are essentially taking a snapshot of the changes that you have made present in the staging area. Lets say you have 5 files ready to be committed in the staging area, when you do a commit you are taking a snapshot of the changes that you have made to these 5 files and giving a message that describes the change.

There is another git command to add the file to the staging area and then commit it directly, you can do that by `git commit -am "This is the message"`. This command is equivalent to running the following command from the root folder `git add . && git commit -m "This is the message"`. There are some caveats here, first this adds all the files in the working directory, so if there are some changes that you didn't wanna include in the first change set that you are commiting, the  this might not be the best option that you are looking for. Secondly, the files that are deleted and the files that are not tracked(new files) doesn't get included in this. This only works well for files that have been modified.

## Show me the differences
Lets say you have made some changes in the working copy. Now we can use the `git diff` command for that. Its shows us the differences between the working copy and the staging index. Its just reports uniquely reports the changes that we have in the working copy, i.e what is unique is the working copy, how is the working copy different from the staging index and the repository. It tells on a line by line basis on what was changed. `git diff <path-to-file>` will just report that changes that have occurred to the particular file. `git diff --staged` command compares the staging area with repository, i.e how is the staging are different from the repository. `git diff --cached` is the equivalent to the `git diff --staged` command. There is also another option called as color-words that you can use with the git diff command to show the changes side by side on the same line and to use color to differentiate the changes, instead of showing it on different lines to show you the change. The command can be used lime this `git diff --color-words <path-to-file>`.

## Deleting a file
Lets say your working copy is in sync with the repository. Now lets say you are removing a file from the working copy, let say you are removing sample.text file. First you delete the file on disk. Now when you run git status, git tells you that I knew a file that I was tracking called as sample.txt but its not present in the working area now. Now as usual to add the file to the staging index you can do `git rm/add sample.txt`. Now if you do git status it should you that a file was deleted. Next to commit this change you can do a git commit. Now you also have another way to do it. Instead of you deleting the file manually on disk, git can take care of that work for you. You can do `git rm sample.txt` this will essentially do `rm sample.txt && git add sample.txt`, i.e its does a Unix delete on the file and adds to the staging area. Now you can just do git commit to capture this change set. When it comes to deleting files I would suggest the 2nd approach, let git handle the work for you. Its more easy and quick way to achieve the result.


## Moving or Renaming a file
Renaming is essentially moving a file if you think about it. Its like deleting the old file and adding the new file. So when you move a file in the working copy you have to do this `git rm/add <old-path>` and then `git add <new-path>`.Now if you do git status it shows that a file has be moved. Next to commit this change you can do a git commit as usual. Instead of doing these work there is another way also in which git can help you in this process. You can do `git mv <old-path> <new-path>` and git will move the file on disk and add the changes to the staging area. Now to can just git commit to complete the process. When it comes to moving files I would suggest the 2nd approach, let git handle the work for you. Its more easy and quick way to achieve the result.

## Undoing changes made to the working copy
This is the most useful feature in git, in fact this is the reason why we use version control at all. The ease to move back to any previous state is what has made this tool very popular. Lets take a look at how we can undo changes in git. The changes that you made in the working directory, changes that you made staged in the staging index or changes that you have even committed in the repository. First lets take a look at how we can undo changes that we have made in the working directory. Lets say we have a file called sample.txt and we make some change in it and save it. But we didn't do it on purpose, now we want the backup version of sample.txt that is in our repository, we want the saved version that git has stored for us to be restored. So we want git to essentially go to the repository checkout the sample.txt file from there and replace what we have in the working directory with it. To do that we use the following command `git checkout sample.txt`.

The git checkout command is used for more that one purpose, its also used along with branches that we will see later. What checkout does is that go to the repository and get the named thing that I gave you and make my working directory look like that. So if that named thing is a branch it brings a branch down, if the named thing is a file it brings the file down. Lets say we have a folder called sample in our working directory in which we have changes in many files, now if we do `git checkout sample` it will checkout the sample folder and replace the sample folder in the working copy with it, that means that now all changes in the sample folder are lost. This is all great, but what if we also had a branch called sample. Then its difficult for git to decided whether we mean a branch or a folder, so git decides to give us the branch by default. Thats why its a good practice to use the `--` option while not checking out a branch. So the best way to checkout the sample folder here would be to `git checkout -- sample`. The `--` option is just to indicate git that we are not checking out a branch, we are just talking about a file or folder in the current branch.

## Undoing changes made to the staging index
Lets say we have a sample.txt file in which we have made some changes and now we have added that file to the staging index. Now how do we unstage this file, i.e how do we remove this file from the staging index. We don't want to loose the changes that we made to this file, we still want the changes to be present in the working directory, all that we want to do it remove this file from the staging index, i.e make the sample.txt file in the staging index look the same as the sample.txt file from the repository. The time when you most often use this when you are trying to put together file for a commit, you have accidentally added a file to the staging index that you didn't want to a part of the change set that you will be commiting. The way to unstage a folder/file is `git reset HEAD <path>`. What we are telling is go and look at the HEAD pointer, the HEAD pointer points to the last commit in the current branch, go look at that commit and reset the file to the same as what that has.

## Undoing changes made to the repository
Now how do we go about undoing changes made to the repository itself. This is not as easy as you might think, it gets a bit trickier here. Because if you think about it, it makes sense. Lets say we have some commit x in the history that we would like to change, now if you remember if we change the data the the checksum will change(checksum depends on the changes made in the files, the commit message, date, author details, parent value of the commit), but checksums are what used to identify commits in git. If checksum of x changes then the parent of the next commit following x needs to change, if the parent value changes then checksum for it must also be changed, and therefore the checksum of every commit following x in the commit history needs the change. All the way down the chain from x every single commit object will need to be changed, we have completely broken the integrity of data thats in git. Git doesn't want us to do that. However it is possible for us to just change the last commit because there are not commits following that. So the most recent commit, the commit that HEAD points to alone has the ability to change. 

So lets say we make a change to the sample.txt file and commit that, but thats not how we wanted the change set to be, so what we can do is make the rework on how we want the changes to be in our working copy and add that to the staging index and then do `git commit --amend -m "This is the message for the commit"`. Doing this removes the last commit and adds this new one. We can also use this if we would like to just change the commit message alone, lets say we have a spelling error in the last commit message that we made the we can just do `git commit --amend -m "This is the new message for the commit"`

## Retrieving old versions
Previously as we have seen that its difficult to amend older commits since it would violate the data integrity in git. But what we can do is we can make a new commit to revert the changes made in a commit. Lets say we have a commit x, but we are happy with the change set that in creates, now what we can do is we can checkout the file from the commit previous to commit x(lets say commit y) and make the changes as we want and commit the changes as a new commit, when we commit this its a good practice to mention that this commits reverts the commit x, so that other people can understand the purpose of this commit. By default when do a `git checkout -- <path>` were actually doing `git checkout HEAD -- <path>` i.e getting the file from the latest commit, instead we could also get a version of file from a previous commit. In our case we need to checkout the file from the commit y, because in commit x the file actually changed. Now to checkout files from the commit y we do the following `git checkout <part-of-sha-value-of-commit-y> -- <path>`. Now when we do this i.e get the version of a file from previous commit the file gets added to the staging area, making it ready for us to commit.

Git also has a revert command that make it easy for us to revert a particular commit lets say as we wanted here we need to revert the commit y, then when we do `git revert <part-of-sha-value-of-commit-y>` it will take all the changes made during commit y and flip it around, it will do exact opposite of the changes anything added will be deleted and anything deleted will be added back again, anything that was modified will be changed back to the previous state. When we execute this command, it going to make that commit it will pop up the default text editor that we gave and give us an option to change the commit message if we want. Now you can pass the `-n` option with revert and it won't actually do the commit, it will just stage it, wait for you to commit by yourself. Now git revert works really well when things are simple, but if in the mean time other things have changes files have moved perhaps, things were renamed, then it would be harder to make an exact mirror image revert. Now to deal with it git will use a complex set of rules for how to deal with those changes, and the set of the rules that we use is the rules for merging. But if you revert something very complex you are essentially gonna find yourself doing a merge between the current branch and the new set of changes that you are trying to merge into it.

## Undoing many commits
Git reset command is a very powerful tool to undo multiple commits. Always remember that more powerful a tool is the more careful and responsible we have to be while using it. With great power comes great responsibility. Git reset always moves the HEAD pointer. But there are 3 different options that we can use with git reset.
- **soft** - Doesn't change the staging area or the working directory
- **mixed**(default) - Changes staging index to match repository, doesn't change the working directory
- **hard** - Changes the staging index and the working directory to match the repository

## Soft reset
Whenever you are working with git reset, its a good idea to take a screen shot of the git log before you proceed any further. Noting down the SHA values can be helpful if you mess up with anything. Lets say we have b as the most recent commit and commit c was made before commit b. Now the HEAD points to the SHA value of commit b. You can check that with `cat .git/refs/heads/master`. Now if you do `git reset --soft <part-of-sha-value-of-commit-c>`, then HEAD will point to the commit c. You can check that with `cat .git/refs/heads/master`, that the value would have changed. Now in fact if you do `git log` you won't find commit b. c will be like the last commit that was made. The working directory will have the changes that we made after commit c. The changes will be ready in the staging area for us to make a commit.

## Mixed reset(Default)
With this type of git reset the staging area will match the repository after the HEAD pointer was made to point to a different one. Just like the previous example lets say we have b as the most recent commit and commit c was made before commit b. Now the HEAD points to the SHA value of commit b. You can check that with `cat .git/refs/heads/master`. Now if you do `git reset --mixed <part-of-sha-value-of-commit-c>`, then HEAD will point to the commit c. You can check that with `cat .git/refs/heads/master`, that the value would have changed. Now in fact if you do `git log` you won't find commit b. c will be like the last commit that was made. The working directory alone will have the changes that we made after commit c. The staging index will not have the changes, it will be identical to the repository. The changes will be ready in the working area for us to stage and make a commit.

In fact if you remember when you need to unstage a file from the staging index you do `git reset HEAD <filename>`, what is essentially happening here is a mixed reset. Since mixed is the default reset you don't actually need the --mixed option if you want to do a mixed reset. Here we are reseting the HEAD pointer to HEAD itself and making the staging area's file match with the repository's version of the file. This is what happens when we additionally give a filename. Not the entire staging area is made to match the repository, only that particular file that was provided is checked out from the repository to the staging index.

## Hard reset
With this type of git reset the staging area and the working directory will match the repository after the HEAD pointer was made to point to a different one. Just like the previous example lets say we have b as the most recent commit and commit c was made before commit b. Now the HEAD points to the SHA value of commit b. You can check that with `cat .git/refs/heads/master`. Now if you do `git reset --hard <part-of-sha-value-of-commit-c>`, then HEAD will point to the commit c. You can check that with `cat .git/refs/heads/master`, that the value would have changed. Now in fact if you do `git log` you won't find commit b. c will be like the last commit that was made. Use this with caution because you will loose all the changes that you made after commit c, there is no place in which we will have the changes that we made after commit c.

## Removing untracked files
This is where the git clean command comes in handy. Lets say you have a bunch of new files that you have added to the project and you would like to remove them, then you could do it manually, but git clean simplifies this process. You cannot use the git clean option as such you have to use it with either the `-n` or the `-f` option. When you do `git clean -n` it will show you the list of new files that git will remove. When you do `git clean -f` git would actually remove the new file from the working copy. Its important to note here that git clean only removes the untracked files, i.e lets say you have added 3 new files sample1.txt, sample2.txt and sample3.txt then let says you add sample3.txt to the staging area. Now when you run `git clean -f` git will remove only the sample1.txt and the sample2.txt file. So git clean removes the untracked files that are there in your working directory.

## Ignoring files
Lets say we are working on a project and we don't want git to track a particular file or a folder. It may be a log file thats constantly changing, or a temporary file, or a folder that contains the project dependencies which is something that we don't wanna be a part of version control. We need a way to tell git to ignore certain files all together. To tell the list of these files and folders that we want git ignore we create a `.gitignore` file in the project root. We can even use very basic regular expressions in the gitignore file. We can negate expression using the `!` character. The following rules means that ignore all html files except the index.html file. The order of writing the rules is important. Git reads the file from top to bottom and keeps overwriting the rules which are already there.
```
*.html
!index.html
```
You can also tell git to ignore all files in a directory by just having a trailing slash. The following rules says git to ignore all files in the photos directory, which is inside of the assets directory.
```
assets/photos/
```
In the gitignore file comments should start with # character, and blank lines in the gitignore files are skipped. Make sure that you commit the gitignore file to the repository. This is a file that we want got to track and maintain, it is as important as any other project files or folders.
```
assets/*.png
```
The above rules will only ignore the png files in the assets folder, if the assets folder has a folder that contains some other png files, those png files will not be ignored, i.e * only applies to the filenames.

## What to ignore ?
- Compiled source code
- Packages & compressed files
- Logs & Databases
- Operating system generated files
- User uploaded assets (images, PDFs, videos)

To start writing gitignore files for your project you can visit [this website](https://www.gitignore.io/) and type a programming language, or operating system as tags to get started with some boilerplate code. They even have a consistent endpoint naming system allowing developers to even access it via APIs. You way also wanna look at github [article](https://help.github.com/articles/ignoring-files/) on ignoring files and the gitignore [project](https://github.com/github/gitignore) created by github.

## Ignoring files globally
If find ignoring certain files over and over for every project, for example like the operating system files. You can configure git globally ignore certain files. Doing this will allow to ignore files in all repositories. The settings that we add for configuring to ignore files globally will not live inside of our project, its gonna be outside. Since it wont be a part of the repository, any other person who is working, when they download our project it will not have this configuration. What we are doing is instead or repository specific ignores we have create user specific ignores. Thats good because having things like .DS_Store in the gitgnore is not good if not every team member is using a mac based operating system. Each person in team can have their own gitignore file specific to their operating system on their machines. There are 2 steps that needs to be done to globally ignore files.
1. Make a global gitignore file in some location
1. Tell git where to look for the global gitignore file

Lets say we create a new file in the home folder called as .gitignore_global that represents the global gitignore file. Next to tell git about that we add the following user level configuration `git config --global core.excludesfile ~/.gitignore_global`.

## Ignoring tracked files
If you want to ignore files that are already being tracked, then what can we do ? First step would be to add it to the list in the gitignore file. But doing this alone will not help. Git will still keep track of the changes. One option is that you can do `git rm <filename>` which would remove the file from the working copy and add the changes to the staging index ready for us to commit. Now we can also add the .gitignore file to the staging area, if we commit now, the file would be removed from the working copy and the repository, and even if we add that file again to the project git will not track it. 

But what if we do not want to loose the working copy that we had. Well you can delete that file from the staging index alone with the command `git rm --cached <filename>`, now add the .gitgnore file to the staging area and make a commit. Now the file would be delete from the repository also. The only place where the file would be present in the working copy, but again it will not show as an untracked file because now we have git ignored it.

## Tracking empty directories
By default git does not track empty directories. That is because git was designed to be a file tracking system, its purpose is to track files and content in those files. So it tracks files and tracks the directories that it takes to get to those files. But it ignores directories that have no files at all. Now lets say we have an empty folder, but we want git to track that folder, how do we tell git to do that. So the trick that we use here to keep track of empty directories in so put a file in them. So the cheat that everyone uses is to put a little tiny file in the folder. By convention the filename that is used for this purpose is a .gitgnore or a .gitkeep file. .gitkeep is the most widely used conventions, you can think of it has a way of telling git to keep tracking that folder. So all that you have to do now to track an empty folder is navigate to that folder and `touch .gitkeep`. Now you can just add that folder to staging index and commit this change set. There is nothing magical happening here we could have named that file anything we want, we just followed a method that everyone uses. The idea behind doing all this is to add a dummy file in the empty folder which git can track (in turn tracking the folder it takes to read that dummy file).

## Looking through commit history
Before we proceed lets look at the ways in which we can reference commits in git. In he git documentation you often see the reference to the work tree-ish. What does it mean ? We know that a tree is a structure of file in the git repository. In git tree-ish means something that reference a part of the tree. Its ish because that something can vary widely. In simpler terms a tree-ish is a reference to a commit. Because that commit in turn references the tree, git repository and the files in there at that point. So if you hard time thinking about all the things a tree-ish can be, the simplest version is that its just something that points at a commit. So lets look at the ways in which we can reference a commit.
- full SHA-1 hash of a commit
- part of SHA-1 hash of a commit (at least 4 characters)
- HEAD pointer ( to reference the latest commit )
- Branch reference ( to point to the tip of the branch )
- Tag reference
- Ancestry

In ancestry we have 2 options. One is that we can use the `^` as a suffix character to refer to a parent of a reference.
Like `HEAD^`,`master^`,`acf9339^`. To get the parent of parent we can use the `^` symbol twice. Second option is we can use the `~` as suffix with number of generations to go up. Like `HEAD~1`, `master~`. If there is no number after ~ it is assumed to be 1, so we can leave off number 1 i.e `HEAD~` is equivalent to `HEAD~1`.
```sh
HEAD^ == HEAD~1 == HEAD~ # refers to the 2nd last commit
HEAD^ == HEAD~1 == HEAD~ == master^ == master~  == master~1 # if the currently checked out branch is master

HEAD^^ == HEAD~2 # refers # refers to the 3rd last commit
HEAD^ == HEAD~2 == master^^  == master~1 # if the currently checked out branch is master
```

## Exploring the commit tree
We can use the git ls-tree command to look at a tree-ish. We use the command like this `git ls-tree <tree-ish>`. So when we do `git ls-tree HEAD`, since HEAD points to the tip of the currently checked out branch, it will return the list of files at that point. In the left you can see that we see blob or tree. A blob is a simple file wheres a tree is nothing but a folder. If were we to checkout these are the files that we would get from the repository. We also just say git to get us the file structure inside a particular path alone, we can do `git ls-tree HEAD^ assets/`, this means that show me the file structure inside the assets folder before making the last commit.

## Navigating the commit log
We have already seen the basics of git log. You should take a look at the git help pages for log because there are so many options there, and you can exactly fine tune the information that you are looking for. Let me walk you through some of the important ones. `git log --online` gives a one line list of whats there in our log file. The command `git log --format=oneline` is also equivalent to the previous one but the only difference is that it returns the full SHA instead of partial. There are other formats also `short`, `medium`(default), `full`, `fuller`,`email`,`raw`. `git log -3` can be used to the number of the recent commits to show. Since every commit has a SHA value we can even provide a range of commits. `git log j8129dh..r3919fh` will show the commits in this range, this range is exclusive of the first and inclusive of the second. We can leave the second SHA value, then it would mean all the way till end i.e it will use HEAD as the default for 2nd one.

We can also provide a path here `git log j8129dh.. index.html` would mean show me all the commits in which index.html file was changes since the commit with SHA value j8129dh was made. We can also provide the `-p` meaning patch option to the git log command to show is the details as to what changes in every commit. It will show the diff in each commit. Similarly the `--stat` will give you some statistics on each commit like the number of lines changes etc and the `--summary` will give a summary on each commit, i.e the number of deletions, additions, and the files changed. There is also a `--graph` option that we can use with the git log command which shows a graphical view of each one of the commits, when we start working with branches this will be very useful, cause it will show the places where we branched out and did the merges. A good combination for the graphical view would be `git log --online --graph --all --decorate` which is worth remembering.

## Looking at a specific commit
Git show command it used to look a a specific commit, what changes we made in a particular commit. `git show <commit-reference>` is used to show details about a particular commit. Its shows the full SHA value of the commit, the author details, the date, the commit message, the diff i.e the changes in the file. As discussed previously we can pass the `--format` option here along with the git show command. Git show can actually show various types of objects, it can show blobs, trees, tags and commits. We were working with commits here, but if we passed in a tree it would show the names of the files and folders inside it, it is equivalent to doing `git ls-tree --only-names <tree>`. For blobs i.e files it shows plain contents. Remember that we can't do `git show index.html` to show the contents of the index.html file. Because index.html is not a tree-ish, it is not a reference what we have to do to see the contents with the git show command is first do `git ls-tree HEAD` and in that get the SHA value of the reference of the index.html file and then do `git show <sha-of-index.html-file>`.